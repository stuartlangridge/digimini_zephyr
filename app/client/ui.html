<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Digimini companion app: UI explorations</title>
<style>
/* inspired by https://dribbble.com/shots/20031358-Connect-devices-on-mobile */
:root {
    /* colour palette from coolors.co */
    --white: #eff8e2; /* honeydew */
    --white-transparent: #eff8e255; /* honeydew */
    --light: #b287a3; /* dusty mauve */
    --medium: #475b5a; /* granite */
    --dark: #23022e; /* dark amethyst */
    --highlight: #bb4430; /* tomato jam */
    --green: #6afebe;
}
@media (width <= 650px) {
}
@media (width > 650px) {
    /* display fake "mobile" view */
    body {
        display: grid;
        align-items: center;
        justify-content: center;
        background: #eee;
    }
    main {
        height: 80vh;
        aspect-ratio: 9 / 19.5;
        border-radius: 4vh;
    }
}
main {
    background: linear-gradient(to bottom, var(--medium) 20%, var(--dark) 60%);
    color: var(--white);
    font-family: system-ui;
    position: relative;
}

h1 {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 5vh;
    font-size: 2vh;
    text-align: center;
    font-weight: normal;
}

digimini-connect {
    button#connect {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 5px;
        border: 0;
        position: absolute;
        top: 25vh;
        left: 50%;
        width: 30vh;
        aspect-ratio: 1/1;
        transform: translateX(-50%);
        border: 2px solid var(--medium);
        box-shadow: 4px 4px 4px rgba(0, 0, 0, 0.5);
    }
    button#connect img.base {
        position: absolute;
        width: 80%;
        height: 80%;
        top: 10%;
        left: 10%;
        object-fit: contain;
    }
    button#connect img.status {
        position: absolute;
        top: 20%;
        left: 40%;
        width: 20%;
        height: 20%;
        object-fit: contain;
    }
    button#connect img.status.static {
        position: absolute;
        top: 10%;
        left: 30%;
        width: 40%;
        height: 50%;
        object-fit: cover;
    }
    button#connect img.status { display: none; }
    button#connect.scanning img.status.scanning,
    button#connect.connected img.status.connected,
    button#connect.static img.status.static {
        display: block;
    }
    output {
        color: var(--highlight);
        position: absolute;
        top: 57vh;
        left: 50%;
        width: 30vh;
        transform: translateX(-50%);
        text-align: center;
        opacity: 1;
        transition: opacity 0.2s ease;
    }
    output:empty {
        opacity: 0;
    }
}

main > * {
    opacity: 0;
    pointer-events: none;
    transition: opacity 250ms ease;
}
main.digimini-connect digimini-connect,
main.digimini-connected digimini-connected {
    opacity: 1;
    pointer-events: auto;
}

digimini-connected {

    &.loading::after {
        content: "";
        width: 100px;
        height: 100px;
        position: absolute;
        top: 13vh;
        left: 35%;
        background: url(scanning-anim.svg) center center no-repeat;
        backgroound-size: contain;
    }

    #disconnect {
        position: absolute;
        top: 5vh;
        left: 50%;
        transform: translateX(-50%);
        margin: 1vh 0;
        border: 2px solid var(--green);
        color: var(--green);
        box-shadow: 4px 4px 4px rgba(0, 0, 0, 0.5);
        background: transparent;
        font-size: 2vh;
        border-radius: 20px;
        height: 4vh;
        padding: 0 2vh;
    }

    #device-images {
        position: absolute;
        top: 12vh;
        left: 0;
        right: 0;
        bottom: 5vh;
        overflow-y: auto;
        overflow-x: visible;
        list-style: none;
        margin: 0 1vh;
        padding: 0;
        width: calc(100% - 1vh - 1vh);
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 10px;
        grid-auto-rows: min-content;
        box-sizing: border-box;
    }
    #device-images li {
        width: 100%;
        position: relative;
    }
    #device-images li:has(img) {
        background: var(--white-transparent); /* polaroid border for images */
    }
    #device-images li::before { /* set box aspect ratio */
        content: "";
        display: inline-block;
        width: 1px;
        height: 0;
        vertical-align: bottom; /* not text baseline; no gap at bottom */
        padding-bottom: calc(100% * 2); /* 1:2 */
    }
    #device-images li img {
        position: absolute;
        width: calc(100% - 2px);
        left: 1px;
        top: 50%;
        transform: translateY(-50%);
        aspect-ratio: 1/2;
        object-fit: contain;
        display: block;
        pointer-events: none;
    }
    #device-images li.add  {
        border: 2px solid var(--green);
        color: var(--green);
        box-shadow: 4px 4px 4px rgba(0, 0, 0, 0.5);
        border-radius: 8px;
        font-size: 8vw;
    }
    #device-images li.add::after {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        content: "+";
        pointer-events: none;
    }
    #device-images li.add input {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
    }
    #device-images li.image button {
        position: absolute;
        width: 100%;
        height: 100%;
        left: 0;
        top: 0;
        background: transparent;
        display: block;
    }        
    #device-images li.image.loading::after {
        content: "";
        position: absolute;
        width: 100%;
        height: 100%;
        left: 0;
        top: 0;
        display: block;
        background: url(static-tv-static.gif) center center no-repeat;
        background-size: cover;
    }        
}
</style>
</head>
<body>
<main class="digimini-connect">
    <digimini-connect>
        <form>
            <h1>Tap to connect digimini</h1>
            <button id="connect" class="awaiting-click">
                <img class="status scanning" src="scanning-anim.svg">
                <img class="status connected" src="smiley.svg">
                <img class="status static" src="static-tv-static.gif">
                <img class="base" src="digimini-symbolic.svg"
                    alt="Tap to connect">
            </button>
            <output></output>
        </form>
    </digimini-connect>

    <digimini-connected>
        <form>
            <h1>Connected to <output>...</output></h1>
            <ul id="device-images">
                <li class="add">
                    <input type="file" id="add-image" 
                     accept="image/*" value="add image"
                     multiple>
                </li>
            </ul>
            <button id="disconnect">Disconnect</button>
        </form>
    </digimini-connected>
</main>

<script>

class FakeBTLEManager {
    async getDevice() {
        await new Promise(r => setTimeout(r, 300)); // fake a delay
        return {name: "mydigimini"}
    }
    async getImagesMeta() {
        // return a list of image names
        await new Promise(r => setTimeout(r, 1500));
        return [
            {name: "im1"},
            {name: "im2"},
            {name: "im3"},
        ]
    }
    async getImageData(imageName) {
        // this should be cached somewhere, but not in here; once it's returned
        await new Promise(r => setTimeout(r, 500));
        return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAIAAAAW4yFwAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAEElEQVQI12P4uI2fiYGBAQALNgG5gDAvrQAAAABJRU5ErkJggg==";
    }
}
const btleManager = new FakeBTLEManager();

class Orchestrator {
    transitionTo(elementName, props) {
        const element = document.querySelector(elementName);
        for (const [prop, value] of Object.entries(props)) {
            element[prop] = value;
        }
        document.querySelector("main").className = elementName;
    }
}
const orchestrator = new Orchestrator();

window.customElements.define(
    'digimini-connect', class extends HTMLElement {
    constructor() {
        super();
        this.device = null;
    }
    connectedCallback() {
        this.button = this.querySelector("button");
        this.button.addEventListener("click", this);
        this.errorOutput = this.querySelector("output");
    }
    disconnectedCallback() {
        this.button.removeEventListener("click", this);
    }
    handleEvent(e) {
        e.preventDefault();
        if (e.target.closest("button") == this.button && e.type == "click") this.clickButton();
    }
    transitionTo(state, call) {
        this.button.className = "static";
        if (call) call.bind(this)();
        setTimeout(() => { this.button.className = state }, 150);
    }
    clickButton() {
        if (this.button.className == "awaiting-click") {
            this.transitionTo("scanning", this.scan);
        }
    }
    async scan() {
        let device;
        let aborted = false;
        function abort() {
            aborted = true;
        }
        console.log("before", this);
        //const timeout = setTimeout(abort.bind(this), 2000); // test abort
        try {
            device = await btleManager.getDevice();
        } catch(e) {
            console.log("Got error when scanning", e);
        }
        if (aborted || !device) {
            this.showError("Couldnâ€™t connect to digimini; please try again");
            this.transitionTo("awaiting-click");
            return;
        }
        console.log("got device", device);
        this.transitionTo("connected", () => {
            orchestrator.transitionTo("digimini-connected", {device})
        });
    }
    showError(text) {
        this.errorOutput.style.opacity = 0;
        this.errorOutput.textContent = text;
        const anim = this.errorOutput.animate([
            {opacity: 0},
            {opacity: 1, offset: 0.2},
            {opacity: 1, offset: 0.8},
            {opacity: 0}
        ], {
            duration: 2000
        })
        anim.onfinish = () => {
            this.errorOutput.style.opacity = 0;
            this.errorOutput.textContent = text;
        }
    }
});


window.customElements.define(
    'digimini-connected', class extends HTMLElement {
    constructor() {
        super();
        this._device = null;
    }
    connectedCallback() {
        this.displayDeviceName = this.querySelector("h1 output");
        this.imageList = this.querySelector("ul#device-images");
        this.imageAddButton = this.querySelector("ul#device-images li #add-image");
        this.imageAddButton.addEventListener("change", this);
        this.imageTemplate = this.querySelector("ul#device-images li").cloneNode(true);
        this.imageTemplate.querySelector("input").remove();
        const imageButton = document.createElement("button");
        imageButton.append("edit");
        this.imageTemplate.append(imageButton);
        this.imageTemplate.className = "image loading";
        this.disconnectButton = this.querySelector("#disconnect");
        console.log(this.disconnectButton)
        this.disconnectButton.addEventListener("click", this);
        this.className = "loading"; /* before images show up */
    }
    set device(adevice) {
        this._device = adevice;
        this.displayDeviceName.textContent = this._device.name;
        this.fetchImages();
    }
    async fetchImages() {
        for (const removeLi of Array.from(this.imageList.querySelector("li"))) {
            if (removeLi.className == "add") continue; // keep add button
            removeLi.remove();
        }

        const imagesMeta = await btleManager.getImagesMeta();
        this.classList.remove("loading"); /* images now showing up */
        for (const imageMeta of imagesMeta) {
            const imgLi = this.imageTemplate.cloneNode(true);
            const button = imgLi.querySelector("button")
            button.dataset.imageName = imageMeta.name;
            button.addEventListener("click", this);
            button.textContent = `Edit ${imageMeta.name}`;
            this.imageList.append(imgLi);
            imageMeta.li = imgLi;
        }


        // get the actual images
        // we can't Promise.race these because we only have one btle line
        for (const imageMeta of imagesMeta) {
            const imageData = await btleManager.getImageData(imageMeta.name);
            const img = document.createElement("img");
            img.src = imageData;
            imageMeta.li.append(img);
            imageMeta.li.classList.remove("loading");
        }
    }
    async handleEvent(e) {
        if (e.type == "click") {
            if (e.target === this.disconnectButton) {
                this.executeDisconnect();
            } else if (e.target.dataset.imageName) {
                this.clickImage(e.target);
            }
        } else if (e.type == "change" && e.target == this.imageAddButton) {
                this.addImage(e);
        }
    }
    async addImage(e) {
        if (e.target.files.length > 0) {
            for (const f of e.target.files) {
                const fileReader = new FileReader(f);
                fileReader.readAsDataURL(f);
                fileReader.addEventListener("load", function () {
                    console.log(f, this.result.substr(0,30));
                });
            }
        }
    }
    async executeDisconnect() {
        console.log("execute disconnect");
    }
    async clickImage(button) {
        console.log("click image", button);
    }
})

</script>
</body>
</html>